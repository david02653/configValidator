- name: record-analyze
  context: general
  isAggregateMethod: false
  accessLevel: service
  description: analyze access record in specific time zone
  method: POST
  atomicIntent: check-record-time
  apiEndpoint: http://check-record-time
  input:
    # AnalysisData.accessTRecord
    - AnalysisData.accessRecord
    - timeZone
  output:
    type: json
    # type: aggregate
    jsonInfo:
      - jsonPath: $.status
        description: access record
        dataLabel: accessRecord
  usedMappingList:
    - mappingName: timeZone
      description: target time zone
      schema: "{start: %{Time.startTime}, end: %{Time.endTime}}"
- name: access-record
  context: general
  isAggregateMethod: false
  accessLevel: service
  description: search user access recor
  method: POST
  atomicIntent: check-user-access
  apiEndpoint: http://check-user-access
  input:
    - User.username
    - Api.serviceName
  output:
    type: json
    jsonInfo:
      - jsonPath: $.record
        dataLabel: accessRecord
        description: access record
  storedData:
    input:
      - from: Api.serviceName
        to: Api.serviceName
    output:
      - from: accessRecord
        to: AnalysisData.accessRecord
- name: Jenkins-health
  context: jenkins
  isAggregateMethod: false
  accessLevel: service
  description: check job health status on jenkins server
  method: POST
  atomicIntent: ask_job_health_report
  apiEndpoint: http://localhost:8888/capability/jenkins-health
  input:
    - User.username
    - Api.accessToken
    - Api.endpoint
    - Api.targetService
  output:
    type: json
    jsonInfo:
      - jsonPath: $[0].description
        description: health summary
        dataLabel: healthSummary
      - jsonPath: $[1].description
        description: build summary
        dataLabel: buildSummary
- name: Jenkins-test-report
  context: jenkins
  isAggregateMethod: false
  accessLevel: service
  description: check test report of specific job on jenkins server
  method: POST
  atomicIntent: ask_job_test_report
  apiEndpoint: http://localhost:8888/capability/jenkins-testReport
  input:
    - User.username
    - Api.accessToken
    - Api.endpoint
    - Api.serviceName
  output:
#    type: json
    type: plainText
    dataLabel: testReport
  storedData:
    input:
      - from: User.username
        to: User.username
      - from: Api.accessToken
        to: Api.accessToken
      - from: Api.serviceName
        to: Api.serviceName
- name: Jenkins-latest-build-number
  context: jenkins
  isAggregateMethod: false
  accessLevel: service
  description: get latest jenkins job build number
  method: POST
  atomicIntent: ask_jenkins_job_build_number
  apiEndpoint: http://localhost:8888/capability/jenkins-buildNumber
  input:
    - User.username
    - Api.accessToken
    - Api.endpoint
    - Api.serviceName
  output:
    type: plainText
    dataLabel: buildNumber
  storedData:
    input:
      - from: User.username
        to: User.username
      - from: Api.accessToken
        to: Api.accessToken
      - from: Api.serviceName
        to: Api.serviceName
    output:
      - from: buildNumber
        to: Api.buildNumber
- name: Jenkins-semi-test-report
  context: jenkins
  isAggregateMethod: false
  accessLevel: service
  description: get jenkins test report
  method: POST
  atomicIntent: ask_jenkins_semi_test_report
  apiEndpoint: http://localhost:8888/capability/jenkins-testReport-semi
  input:
    - User.username
    - Api.accessToken
    - Api.endpoint
    - Api.serviceName
    - Api.buildNumber
  output:
    type: plainText
    dataLabel: testReport
  storedData:
    input:
      - from: User.username
        to: User.username
      - from: Api.accessToken
        to: Api.accessToken
      - from: Api.serviceName
        to: Api.serviceName
- name: Jenkins-view-list
  context: jenkins
  isAggregateMethod: false
  accessLevel: system
  description: get jenkins view list
  method: POST
  atomicIntent: ask_job_view_list
  apiEndpoint: http://localhost:8888/capability/jenkins-view-list
  input:
    - jenkinsInfo
  output:
    type: plainText
    dataLabel: viewList
  usedMappingList:
    - mappingName: jenkinsInfo
      description: basic jenkins information
      schema: "{name: %{User.username}, token: %{Api.accessToken}, url: %{Api.endpoint}}"
- name: Fake-test-capability
  context: general
  isAggregateMethod: false
  accessLevel: service
  description: try to use get method with request param
  method: GET
  atomicIntent: get_this
  apiEndpoint: http://localhost:8888/capability/fake
  input:
    - User.username
    - Api.accessToken
  output:
    type: plainText
- name: Fake-capability-pathvariable
  context: general
  isAggregateMethod: false
  accessLevel: service
  description: try to use get method with path variable
  method: GET
  atomicIntent: get_path
  apiEndpoint: http://localhost:8888/capability/fake-variable/{User-username}
  input:
    - User-username
  output:
    type: plainText
- name: illegal-capability
  context: general
  isAggregateMethod: false
  accessLevel: service
  description: dummy illegal capability
  method: POST
  atomicIntent: none
  apiEndpoint: url
  input:
    - fake.input
    - User.name
  output:
    type: plainText
# aggregate capability config example
- name: full-example-of-aggregate-capability
  context: general
  isAggregateMethod: true
  # use accessLevel to define what service is used in this capability
  # example: analyze something about service x -> service level
  # example: analyze something about system z -> system level
  accessLevel: system
  description: full example of aggregate capability
  # method, apiEndpoint are used to define 'how to access the aggregate endpoint'
  method: POST
  # atomicIntent defines what intent used to trigger this capability, has nothing to do here since this is an aggregate capability
  atomicIntent: none
  apiEndpoint: full-aggregate-example
  # no need to use input since aggregation capability use 'aggregateSource' to define what data should be used
  # no need to use output since aggregation result has fixed format, and it is nearly unable to predict what service might be used in the first place
  # use aggregateDetail to define what kind of data should be used and where do they come from
  input:
  output:
  aggregateDetail:
    # determine if this aggregation result needs to be stored or not
    storeResult: true
    usedMaterial:
      context:
        - jenkins
        - eureka
#      service:
#        - serviceA
#        - serviceB
      property:
        - User.username
    dataSource:
      - useAs: username
        isAggregationData: false
        context: jenkins
        from: User.username
      - useAs: aggregate-result-1
        isAggregationData: true
        aggregationLevel: service
        aggregateDataMaterial:
          context:
            - jenkins
          property:
            - User.username
      - useAs: aggregate-result-2
        isAggregationData: true
        aggregationLevel: system
        aggregateDataMaterial:
          context:
            - eureka
          property:
            - User.username
# rendering capability example
- name: rendering example
  isRenderingMethod: true
  description: rendering capability example
  method: POST
  atomicIntent: none
  apiEndpoint: rendering_endpoint
  input:
  output:
  renderingDetail:
    dataSource:
      - useAs: username
        isAggregationData: false
        context: jenkins
        from: User.username
      - useAs: aggregate-result-1
        isAggregationData: true
        aggregationLevel: service
        aggregateDataMaterial:
          context:
            - jenkins
          property:
            - User.username
      - useAs: aggregate-result-2
        isAggregationData: true
        aggregationLevel: system
        aggregateDataMaterial:
          context:
            - eureka
          property:
            - User.username
- name: Pseudo-service-detail
  context: pseudo
  isAggregateMethod: false
  accessLevel: service
  description: check service detail
  method: POST
  atomicIntent: none
  apiEndpoint: http://localhost:8888/capability/pseudo-detail
  input:
    - Api.serviceName
    - Api.accessToken
  output:
    type: plainText
    dataLabel: serviceDetail
  storedData:
    output:
      - from: serviceDetail
        to: Data.information
- name: Pseudo-service-api-detail
  context: pseudo2
  isAggregateMethod: false
  accessLevel: service
  description: check service api detail
  method: POST
  atomicIntent: none
  apiEndpoint: http://localhost:8888/capability/pseudo-api
  input:
    - Api.serviceName
    - Api.accessToken
  output:
    type: plainText
    dataLabel: apiNumber
  storedData:
    output:
      - from: apiNumber
        to: AnalysisData.countNumber
- name: pseudo-aggregate
  context: general
  isAggregateMethod: true
  accessLevel: system
  description: aggregate pseudo service detail
  method: POST
  atomicIntent: none
  apiEndpoint: http://localhost:8888/capability/pseudo-aggregate
  input:
  output:
  aggregateDetail:
    storeResult: true
    usedMaterial:
      context:
        - pseudo
        - pseudo2
      property:
        - Data.information
        - AnalysisData.countNumber
    dataSource:
      - useAs: serviceDetail
        isAggregationData: false
        context: pseudo
        from: Data.information
      - useAs: apiDetail
        isAggregationData: false
        context: pseudo2
        from: AnalysisData.countNumber